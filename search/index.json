[{"content":"Lập trình là gì? Người ta dùng ngôn ngữ chuyên dụng để tạo nên chương trình theo đơn vị module đã chia ở bước thiết kế chi tiết phần mềm. Công việc tạo lập này được gọi là Lập trình - Programming (Coding)\n※Hãy biết cả điều này nữa\n*Tiêu chuẩn hóa lập trình* Việc quyết định quy tắc nhất định như đặt tên biến hay comment... với mục đích khiến cho nội dung xử lý của chương trình trở nên dễ hiểu được gọi là *Tiêu chuẩn hóa lập trình*. Nó có hiệu quả là giúp chương trình dễ đọc, phòng ngừa trước những lỗi mà lập trình viên dễ phạm phải.  Ngôn ngữ lập trình Ngôn ngữ chuyên dụng để viết chương trình được gọi là Ngôn ngữ lập trình. Có nhiều loại khác nhau trong ngôn ngữ lập trình. Ngôn ngữ lập trình mà máy tính dễ hiểu hơn được gọi là Ngôn ngữ bậc thấp, ngôn ngữ lập trình dễ hiểu đối với con người được gọi là Ngôn ngữ bậc cao. Trong ngôn ngữ bậc thấp có các loại như ngôn ngữ máy, ngôn ngữ Assembly\u0026hellip; Ngược lại, trong ngôn ngữ bậc cao có COBOL, FORTRAN, C, BASIC, Pascal, C++, Java\u0026hellip;\nLanguage processor (Bộ xử lý ngôn ngữ) Máy tính chỉ có thể hiểu được chương trình viết bằng ngôn ngữ máy. Do đó, Chương trình gốc (Source program) là chương trình do con người mô tả không thể nào giữ nguyên như thế mà chạy trên máy tính được. Vì vậy, cần sử dụng chương trình dịch gọi là Language processor để dịch ra Chương trình đích là chương trình ngôn ngữ máy.\n \nTùy theo cách dịch mà có thể phân loại Language processor ra thành Assembler, Compiler, Generator, Interpreter\n \nAssembler Assembler là Language processor dịch chương trình gốc được viết bằng ngôn ngữ Assembly sang chương trình đích. Ngôn ngữ Assembly phân chia ký hiệu ra thành ngôn ngữ máy, lệnh được dịch sang ngôn ngữ máy theo nguyên tắc 1-1. Việc dịch bằng Assembler được gọi là Assemble.\nCompiler Compiler là Language processor tổng hợp lại một lần chương trình gốc được viết bằng ngôn ngữ bậc cao rồi mới dịch sang chương trình đích. Việc dịch bằng compiler được gọi là Compile\nGenerator Generator là Language processor tự động generate ra chương trình ứng với mục đích xử lý, bằng cách chỉ thị những điều kiện cần thiết như nhập vào, xử lý, xuất ra,\u0026hellip; bằng parameter là giá trị setting.\nInterpreter Interpreter là Language processor diễn giải rồi chạy từng dòng một chương trình được viết bằng ngôn ngữ bậc cao. Do không tạo ra chương trình đích với ngôn ngữ máy, nên cần phải diễn giải cứ mỗi khi chạy, khiến tốc độ chạy chương trình chậm đi. Dù có lỗi cú pháp ở giữa chừng chương trình thì interpreter vẫn có thể chạy đến ngay trước lỗi đó.\n※Chỗ này thường ra này!\n*Thuật ngữ* [アセンブラ] (Assembler): Dịch chương trình gốc được viết bằng ngôn ngữ Assembly sang ngôn ngữ máy [コンパイラ] (Compiler): Tổng hợp lại chương trình gốc rồi dịch một lần sang ngôn ngữ máy [ジェネレータ] (Generator): Chỉ thị từ parameter, tự động generate ra chương trình ứng với mục đích của xử lý [インタプリタ] (Interpreter): Diễn giải rồi chạy từng lệnh 1 của chương trình gốc  ※Hãy biết cả điều này nữa\n*Translator và Emulator* *Translator* là chương trình chuyển đổi chương trình gốc được viết cho xử lý nào đó thành chương trình gốc cho xử lý khác. *Emulator* là vi chương trình (micro program) giải mã, thực thi chương trình dùng cho máy tính khác.  Các bước cho đến khi chạy phần mềm Ta sẽ đi xem các bước đến khi một chương trình được viết bằng ngôn ngữ bậc cao theo phương thức Compiler trở thành phần mềm và được thực thi.\n \n① Compile Trước tiên, nhờ vào Compiler, dịch chương trình gốc được viết bằng ngôn ngữ bậc cao sang chương trình đích với ngôn ngữ máy. Lúc này, sẽ đi phân tích chương trình gốc, việc tối ưu hóa sẽ được thực hiện để nâng cao hiệu quả xử lý khi thực thi.\n② Link Khi tạo chương trình, không thể chạy với đơn lẻ một chương trình đích mà chỉ mới thực hiện compile. Cần phải gọi chương trình trong library module từ chương trình đích, gọi ra xử lý được viết ở chương trình gốc khác. Library module tức là tập hợp các chương trình đã bộ phận hóa để có thể sử dụng chương trình chứa chức năng xác định nào đó từ chương trình khác. Tại đó, bổ sung thêm các library module cần thiết vào chương trình đích đã được dịch bằng compiler, rồi generate ra Load module là chương trình có thể thực thi. Công việc này được gọi là Link (Liên kết), chương trình thực hiện link được gọi là Linker. Trong link thì có Link tĩnh và Link động. Link tĩnh là phương pháp link chương trình đích hay library module cần thiết bằng Linker trước khi chạy chương trình. Link động là cách link mà khi cần chức năng thuộc program module khác trong khi chạy chương trình, thì sẽ link chương trình đó bất cứ lúc nào cần. Library file tổng hợp nhóm module phần mềm với tiền đề link động được gọi là DLL (Dynamic Link Library - thư viện liên kết động).\n③ Load Công việc tải vào bộ nhớ chính để chạy load module được gọi là Load, do chương trình gọi là Loader đảm nhiệm.\n※Chỗ này thường ra này!\n*Thuật ngữ* [最適化] (Tối ưu hóa): Khi compile, phân tích chương trình gốc, tạo chương trình đích nâng cao hiệu suất xử lý khi thực thi [リンク] (Link): Kết hợp chương trình đích hay library module rồi generate ra Load module [ロード] (Load): Bố trí load module vào bộ nhớ chính  ※Chỗ này thường ra này!\n*Thuật ngữ* [動的リンク] (Link động): Trong khi đang chạy application, tùy theo độ cần thiết mà gọi thư viện liên kết động, kết hợp với bản thể chương trình  ※Hãy biết cả điều này nữa\n*Refactoring* Việc thay đổi cấu trúc bên trong chương trình thay vì thay đổi spec bên ngoài để nâng cao tính bảo trì của phần mềm được gọi là *Refactoring*  Tính chất của chương trình Một chương trình hoạt động nhanh, chính xác có thể nói là chương trình tốt, nhưng để tạo ra chương trình tốt như thế, quan trọng là phải hiểu được 4 tính chất của chương trình.\nCó thể tái sử dụng nối tiếp (Reusable) Chương trình có thể chạy kể cả sau khi đã tạm thời chạy xong, dù không load lại lần nữa vào bộ nhớ chính được gọi là chương trình có thể tái sử dụng. Trong đó, chương trình chỉ có thể sử dụng 1 tác vụ cùng một lúc gọi là Chương trình có thể tái sử dụng liên tiếp.\nCó thể tái nhập (Reentrant) Trong số các chương trình có thể tái sử dụng, chương trình gọi cùng lúc từ 2 tác vụ trở lên mà vẫn hoạt động đúng được gọi là Chương trình có thể tái nhập. Do chương trình có thể tái nhập có phần code (thủ tục) và phần dữ liệu được chia ra ở từng vùng bộ nhớ riêng biệt, nên có thể xếp hàng rồi chạy bằng cách chuẩn bị phần dữ liệu theo từng tác vụ.\nCó thể tái định vị (Relocatable) Chương trình có thể chạy dù load ở bất cứ vị trí nào trong bộ nhớ chính được gọi là Chương trình có thể tái định vị.\nMang tính đệ quy (Recursive) Chương trình có thể tự gọi bản thân nó trong khi đang chạy gọi là Chương trình mang tính đệ quy.\n※Hãy biết cả điều này nữa\n*Reverse engineering* Việc phân tích source code của chương trình, rồi dựng lại thông tin thiết kế hay spec của chương trình được gọi là *Reverse engineering*. Ví dụ, từ thông tin định nghĩa hệ thống cơ sở dữ liệu đang hoạt động trên thực tế, sử dụng tool tạo ERD, sinh ra bản thiết kế thể hiện bằng ERD, hay sinh ra sơ đồ class UML từ chương trình tương ứng với công việc này.  ※Chỗ này thường ra này!\n*Thuật ngữ* [逐次再使用可能] (Có thể tái sử dụng nối tiếp): Miễn load 1 lần là có thể chạy bao nhiêu lần. Chỉ có thể sử dụng 1 tác vụ [再入可能] (Có thể tái nhập): Có thể sử dụng với nhiều tác vụ cùng một lúc [再配置可能] (Có thể tái định vị): Dù load ở bất cứ vị trí nào trên bộ nhớ chính thì vẫn có thể chạy [再帰的] (Mang tính đệ quy): Có thể tự gọi bản thân nó [リバースエンジニアリング] (Reverse engineering): Phân tích source code, dựng lại cấu trúc hay spec bên trong  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 22) Khi xử lý của program A nọ chưa kết thúc, dù bị gọi lại từ program khác nhưng vẫn hoạt động đúng, thì lúc này, tính chất của program A này gọi là gì? ア: Mang tính đệ quy イ: Có thể tái sử dụng ウ: Có thể tái nhập エ: Có thể tái định vị → Answer: ウ Giải thích: Dù bị gọi từ 2 chương trình trở lên cùng một lúc nhưng vẫn có thể chạy là Chương trình có thể tái nhập.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 21) Sơ đồ bên dưới diễn tả flow dịch rồi thực thi chương trình. Cùng kết hợp với input, output là Compiler, Linker, Loader, thì phương án nào dưới đây là phù hợp nhất?   \n→ Answer: ア Giải thích: Khi dịch chương trình gốc bằng Compiler, có thể ra \u0026quot;Chương trình đích\u0026quot;. Hơn nữa, \u0026quot;Chương trình đích\u0026quot; ghép thêm \u0026quot;Library module\u0026quot; vào bằng Linker, sẽ ra \u0026quot;Load module\u0026quot; có thể chạy, và được bố trí ở trên bộ nhớ chính bằng Loader.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa thu năm Heisei 26) Việc sinh ra sơ đồ class UML từ program được gọi là gì? ア: Backtracking イ: Forward Engineering ウ: Re‑engineering エ: Reverse engineering → Answer: エ Giải thích: Sơ đồ class UML là sơ đồ thiết kế chương trình hướng đối tượng. Việc phân tích chương trình, rút ra spec hay cấu trúc bên trọng được gọi là Reverse engineering. ","date":"2021-09-23T20:00:00+07:00","permalink":"https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/","title":"FE Book_Chapter 5: System development_Lesson 5-6: Lập trình"},{"content":"Thiết kế cấu trúc hóa chương trình Trong thiết kế chi tiết phần mềm, ta chia program ra thành đơn vị chứa một cụm chức năng được gọi là Module. Ta gọi việc này là thiết kế cấu trúc hóa chương trình. Bằng cách chia chương trình ra thành nhiều module, sẽ có thể phát triển chương trình với nhiều người đảm nhiệm. Hơn nữa, do có thể test theo đơn vị module, nên dù có xảy ra vấn đề thì cũng dễ dàng xác định được nguyên nhân, chỉ cần fix trong module là được.\n \nTính độc lập của module Để nâng cao tính tin cậy và tính bảo trì của chương trình, người ta cố gắng giảm bớt chức năng bỏ trong 1 module hết sức có thể, nâng cao tính độc lập của các module. Bởi vì tính độc lập càng cao, thì dù có module nào đó bị trục trặc hay thay đổi, thì ảnh hưởng đến các module khác càng ít đi. Tính độc lập của module đánh giá bằng độ mạnh của module và độ gắn kết của module.\nĐộ mạnh của module Thứ thể hiện độ mạnh về quan hệ giữa các chức năng trong 1 module gọi là Độ mạnh của module. Tùy theo cách liên hệ giữa module với nhau mà phân ra làm 7 loại dưới đây. Độ mạnh của module càng lớn thì tính độc lập của module càng cao.\n \nĐộ gắn kết của module Thứ thể hiện độ mạnh của quan hệ giữa các module được gọi là Độ gắn kết của module. Tùy theo cách liên hệ giữa module với nhau mà phân ra làm 6 loại dưới đây. Độ gắn kết của module càng yếu thì tính độc lập của module càng cao.\n \n※Hãy biết về bài thi\nVì trong bài thi sẽ có hỏi nhiều về cái mạnh nhất hay yếu nhất trong Độ mạnh của module hay Độ gắn kết của module, nên ta hãy nắm thật rõ về thứ mạnh nhất, yếu nhất, và đặc biệt rõ đến mức nội dung. Và hãy chú ý đọc kỹ đề bài, xem thứ được hỏi là về độ mạnh hay độ gắn kết, đừng để bị nhầm  ※Chỗ này thường ra này!\n*Thuật ngữ* [モジュール強度] (Độ mạnh của module - Module Cohesion): Mạnh nhất là độ mạnh mang tính chức năng (Functional cohesion), yếu nhất là độ mạnh mang tính mật mã (Coincidental). Càng mạnh thì tính độc lập của module càng cao. [モジュール結合度] (Độ gắn kết của module - Module Coupling): Mạnh nhất là gắn kết nội bộ (Content coupling), yếu nhất là gắn kết dữ liệu (Data coupling). Càng yếu thì tính độc lập của module càng cao.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 20) Để nâng cao tính độc lập của module, cần phải chỉnh cho độ gắn kết của module yếu đi. Trong số các cách truyền thông tin giữa các module, cái nào dưới đây có độ gắn kết module là yếu nhất? ア: Module liên quan tham chiếu dữ liệu định nghĩa ở khu vực chung イ: Truyền tham số kiểm soát làm đối số, control trật tự chạy của module ウ: Chỉ truyền mục dữ liệu làm đối số giữa các module エ: Khai báo bên ngoài và chia sẻ những dữ liệu cần thiết → Answer: ウ Giải thích: Nếu sắp xếp theo thứ tự độ gắn kết từ mạnh đến yếu, thì sẽ là ア) Gắn kết chung (Common coupling), エ) Gắn kết bên ngoài (External coupling), イ) Gắn kết kiểm soát (Control coupling), ウ) Gắn kết dữ liệu (Data coupling), và ウ) Gắn kết dữ liệu (Data coupling) là cái có độ gắn kết module yếu nhất.  *Note:\nĐây là một bài viết nặng về lý thuyết và yêu cầu cần có hiểu biết cũng như kinh nghiệm về kỹ thuật. Do dịch từ tiếng Nhật nên cách dùng từ có thể chưa được hợp lý. Mình đã tìm hiểu và chú thích thêm khái niệm trong tiếng Anh để dễ hiểu hơn. Tuy nhiên, còn nhiều chỗ giải thích chưa được đầy đủ, rõ ràng và chưa có phần ví dụ. Để tìm hiểu thêm, bạn có thể tham khảo các tài liệu dưới đây, cũng như tra cứu bằng các từ khóa có trong bài.\nReference:\n https://viblo.asia/p/tim-hieu-ve-coupling-va-cohesion-bJzKmo7El9N https://edwardthienhoang.wordpress.com/2018/01/08/low-coupling-and-high-cohesion/ https://online.grokking.org/links/401/coupling-la-gi- http://www.kogures.com/hitoshi/webtext/kj2-module/  ","date":"2021-07-12T18:00:00+07:00","permalink":"https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-5-thi%E1%BA%BFt-k%E1%BA%BF-chi-ti%E1%BA%BFt-ph%E1%BA%A7n-m%E1%BB%81m/","title":"FE Book_Chapter 5: System development_Lesson 5-5: Thiết kế chi tiết phần mềm"},{"content":"Thiết kế human interface Ở định nghĩa yêu cầu phần mềm thiết kế phần bề ngoài của hệ thống (External design), ta sẽ thiết kế các cách hiển thị thông tin đối với user hay những màn hình mà user sẽ thao tác thực tế. Phần gắn kết user với máy tính kiểu như vậy được gọi là Human interface. Human interface cần phải suy nghĩ xem \u0026ldquo;Có dễ dàng sử dụng đối với user hay không\u0026rdquo; để còn thiết kế. \u0026ldquo;Tính dễ dàng sử dụng\u0026rdquo; được gọi là Usability.\n※Chỗ này thường ra này!\n*Thuật ngữ* [ヒューマンインタフェース] (Human interface): Suy nghĩ đến usability (tính khả dụng) để thiết kế  GUI GUI (Graphical User Interface) hiện tại đang rất phổ biến cũng là thứ có suy xét đến usability. GUI tức là user interface (giao diện người dùng) sử dụng hình minh hoạ để hiển thị thông tin cho user. Do những máy tính trước đây hiển thị bằng chữ cái, thao tác cũng thực hiện bằng cách nhập chữ, nên những ai không có kiến thức chuyên môn sẽ không thao tác được. Tuy nhiên, do GUI hiển thị bằng hình minh họa thay vì bằng chữ cái, có thể dùng chuột để thao tác, nên có thể thao tác một cách trực quan.\n GUI \nThiết kế màn hình GUI Ở thiết kế màn hình GUI, ta có thể cho hiển thị nội dung thao tác của hệ thống phát triển theo kiểu menu. Ta quan tâm đến usability, cố gắng hết sức để hình dạng hay vị trí của các button hay menu chung ở màn hình nào cũng giống nhau. Thêm nữa, ở màn hình user nhập dữ liệu, bằng cách cố gắng bỏ công chuẩn bị trước các phương án lựa chọn, thì sẽ có thể giảm bớt công sức, thời gian nhập vào cho user. Cụ thể, ta có thể thiết kế bộ phận kiểu như dưới đây\n Design screen of GUI \n※Hãy biết cả điều này nữa\n*Chức năng macro* Chức năng gom một loạt các câu lệnh lại làm một, chạy bằng 1 câu lệnh được gọi là *Chức năng macro*. Nó được sử dụng với mục đích giảm bớt số lượng thao tác của user thực hiện những tác vụ cố định thường xuyên  ※Chỗ này thường ra này!\n*Thuật ngữ* [プルダウンメニュー] (Pull down menu): Khi click vào button thì các mục chọn hiển thị ra làm một list [チェックボックス] (Check box): Có thể chọn nhiều từ trong số các phương án [ラジオボタン] (Radio button): Chỉ có thể chọn 1 từ trong số các phương án [リストボックス] (List box): Các phương án lựa chọn hiển thị ra theo menu [マクロ機能] (Chức năng macro): Gộp một chuỗi các câu lệnh lại làm một rồi chạy  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa thu năm Heisei 25) Ở một cửa hàng nọ, đang quản lý khoảng 200 mặt hàng. Trong số các mục nhập ở màn hình Đăng ký mới dữ liệu sản phẩm, thứ nào dưới đây là thích hợp để sử dụng Pull down menu làm phương thức nhập? | | Mục | Hình thức và quy tắc | | -- | ------------------ | ------------------------------------------------------------------------ | | ア | Mã số sản phẩm | Là mục chữ và số tiếng Anh có 5 ký tự, đánh số theo từng sản phẩm | | イ | Tên sản phẩm | Là mục tiếng Nhật trong vòng 40 ký tự trở lại, đặt tên theo từng sản phẩm | | ウ | Phân loại sản phẩm | Là mục tiếng Nhật trong vòng 10 ký tự trở lại, có 5 phân loại | | エ | Giá | Là mục số có 6 chữ số, phạm vi từ 10,000 ~ 100,000 yên | → Answer: ウ Giải thích: Pull down menu là khi click vào button, các mục lựa chọn sẽ hiển thị ra làm một list. Do đó, nó sẽ thích hợp với phương thức nhập Phân loại sản phẩm có số mục chọn giới hạn  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 26) Trong số các chức năng Human interface, thứ được sử dụng với mục đích giảm bớt số thao tác của người dùng thực hiện các tác vụ cố định một cách thường xuyên là cái nào dưới đây? ア: Chức năng macro gom một chuỗi các câu lệnh lại làm một イ: Chức năng gom lại và hiển thị input error ở màn hình cuối cùng ウ: Chức năng hiển thị hiện tại đang tiến hành đến đâu trong số tất cả công đoạn エ: Chức năng có thể trả về trạng thái trước đó khi thao tác bị nhầm → Answer: ア Giải thích: Khi sử dụng chức năng macro gom một chuỗi các tác vụ lại rồi chạy luôn một lần, có thể giảm số thao tác của người dùng ","date":"2021-06-20T18:00:00+07:00","permalink":"https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-4-%C4%91%E1%BB%8Bnh-ngh%C4%A9a-y%C3%AAu-c%E1%BA%A7u-ph%E1%BA%A7n-m%E1%BB%81m-external-design/","title":"FE Book_Chapter 5: System development_Lesson 5-4: Định nghĩa yêu cầu phần mềm (External design)"},{"content":"Phương pháp mô hình hóa Vào lúc bắt đầu phát triển hệ thống, trước tiên, ta sẽ dùng sơ đồ để giải thích một cách dễ hiểu quy trình nghiệp vụ (business process), hay quan hệ giữa các thông tin sẽ sử dụng (data class) mà ta định tạo thành hệ thống. Công việc này được gọi là Mô hình hóa nghiệp vụ. Hãy cùng xem những cách dùng sơ đồ lý giải được sử dụng khi mô hình hóa nhé.\nDFD (Sơ đồ luồng dữ liệu) DFD (Data Flow Diagram) là phương pháp lý giải bằng sơ đồ chú trọng đến luồng dữ liệu, từ đó phân tích nghiệp vụ đối tượng. Nó có ưu điểm là dễ dàng check được nội dung nghiệp vụ bằng cách biến luồng dữ liệu (data flow) và quy trình xử lý dữ liệu thành sơ đồ. Tuy nhiên, DFD không thể diễn tả về thời gian, ví dụ như thời điểm xử lý. Ký hiệu được sử dụng trong DFD có 4 loại dưới đây.\n\u0026lt;Các ký hiệu sử dụng trong DFD\u0026gt;\n   Ký hiệu Tên gọi Ý nghĩa      Data store  Data store Lưu trữ dữ liệu như file, business form hay database\u0026hellip;    Data flow  Data flow Luồng dữ liệu. Phía trên luồng dữ liệu sẽ ghi mô tả tên dữ liệu    Process  Process Xử lý hay biến đổi dữ liệu    Source-or-Destination  Nguồn phát sinh dữ liệu (nguồn); Điểm đến của dữ liệu (hấp thụ) Nguồn phát sinh, hoặc là điểm đến cuối cùng của dữ liệu     DFD Example \nSơ đồ E-R Sơ đồ E-R (Entity-Relationship Diagram) là thứ thể hiện cấu trúc dữ liệu bởi 2 khái niệm Thực thể (Entity) và Mối quan hệ (Relationship) giữa các thực thể với nhau, được dùng trong việc phân tích sự liên quan giữa các dữ liệu. Trên sơ đồ E-R, ta vẽ \u0026ldquo;Thực thể\u0026rdquo; bằng hình chữ nhật, thể hiện \u0026ldquo;Mối liên quan giữa các thực thể\u0026rdquo; bằng đường thẳng hoặc dấu mũi tên. Tùy theo sự khác biệt về quan hệ, mà chia ra làm 4 loại dưới đây.\n ERD \nVí dụ, ta sẽ thử đi vẽ sơ đồ E-R cho quy trình nghiệp vụ đơn giản nhất là \u0026ldquo;Khách hàng thực hiện order\u0026rdquo;. Nếu thử suy nghĩ theo hướng \u0026ldquo;Order\u0026rdquo; từ \u0026ldquo;Khách hàng\u0026rdquo;, thì do 1 khách hàng sẽ đặt nhiều order, nên sẽ là quan hệ 1 nhiều (1-n) Ngược lại, nếu suy nghĩ theo hướng \u0026ldquo;Khách hàng\u0026rdquo; từ \u0026ldquo;Order\u0026rdquo;, thì vì 1 order được đặt từ 1 khách hàng, nên sẽ là quan hệ 1 1. Do đó, sẽ ra mô tả sơ đồ E-R như dưới đây:\n ERD Example \nSơ đồ chuyển đổi trạng thái Sơ đồ chuyển đổi trạng thái là sơ đồ được sử dụng khi mô tả hoạt động sẽ thực thi đi theo cùng động lực gây biến đổi trạng thái như trải qua một khoảng thời gian hay có tín hiệu kiểm soát,\u0026hellip; và sự biến đổi. Nó rất tiện trong việc phân tích hay thiết kế hệ thống mang tính real time - điều mà DFD không làm được tốt. Trong phát triển hệ thống, nó được sử dụng để thể hiện những thay đổi về nghiệp vụ hay di chuyển màn hình\u0026hellip;\n State Transition Diagram \n※Chỗ này thường ra này!\n*Thuật ngữ* [DFD]: Chú trọng đến luồng dữ liệu để thể hiện [E-R図] (Sơ đồ E-R, ERD): Chú trọng đến Thực thể (Entity) và Quan hệ (Relationship) giữa các thực thể để thể hiện cấu trúc dữ liệu [状態遷移図] (Sơ đồ chuyển đổi trạng thái): Thể hiện sự chuyển đổi trạng thái của hệ thống. Được áp dụng cho hệ thống real time  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 27) Giải thích cho Sơ đồ E-R là cái nào dưới đây? ア: Là sơ đồ thể hiện model hướng đối tượng イ: Là sơ đồ thể hiện tình hình trạng thái biến đổi theo thời gian hay hành động,... ウ: Là sơ đồ thể hiện thế giới đối tượng bởi 2 khái niệm là Thực thể và Quan hệ エ: Là sơ đồ thể hiện một cách dễ hiểu, trực quan luồng dữ liệu → Answer: ウ Giải thích: Sơ đồ E-R là sơ đồ chú trọng đến thực thể và mối quan hệ giữa các thực thể để thể hiện thông tin.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 25) Khi thiết kế, hệ thống nào dưới đây là thích hợp nhất để sử dụng sơ đồ chuyển đổi trạng thái? ア: Hệ thống kiểm kê tồn kho xử lý tính tổng tài sản kiểm kê vào cuối tháng và khi quyết toán イ: Hệ thống báo cáo tình hình hoạt động tài nguyên hệ thống, lấy tình hình hoạt động hàng ngày của tài nguyên hệ thống để xuất ra làm report ウ: Hệ thống tính toán tiền nước bằng cách nhập dữ liệu đồng hồ đo nước sinh hoạt để tính toán tiền phí エ: Hệ thống kiểm soát nhiệt độ, giữ môi trường trong nhà kính ở mức hợp lý nhất từ thông tin cảm biến được lắp đặt → Answer: エ Giải thích: Sơ đồ chuyển đổi trạng thái thích hợp để thiết kế hệ thống real time giống như hệ thống kiểm soát nhiệt độ  ","date":"2021-05-02T19:00:00+07:00","permalink":"https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-3-m%C3%B4-h%C3%ACnh-h%C3%B3a-nghi%E1%BB%87p-v%E1%BB%A5/","title":"FE Book_Chapter 5: System development_Lesson 5-3: Mô hình hóa nghiệp vụ"},{"content":"Các phương pháp phát triển hệ thống Có một số loại trong cách tiến hành phát triển, ở những loại chính ta có Waterfall model, Prototyping model, Spiral model.\nWaterfall model Phương pháp phát triển tiến hành theo trình tự \u0026ldquo;Định nghĩa yêu cầu\u0026rdquo; → \u0026ldquo;Thiết kế hệ thống\u0026rdquo; → \u0026ldquo;Lập trình\u0026rdquo; → \u0026ldquo;Test\u0026rdquo; được gọi là Waterfall model. Thứ đã giải thích ở \u0026ldquo;5-1 Khái quát phát triển hệ thống\u0026rdquo; chính là phương pháp phát triển này. Do tiến hành theo trình tự từ đầu, nên nó có đặc trưng là dễ nắm được tình hình tiến triển. Ngược lại, một khi đã tiến qua process tiếp theo, sẽ khó quay trở về process trước đó để chỉnh sửa, nên khi mỗi một công đoạn kết thúc, cần phải check thật kỹ để không phải quay trở lại công đoạn trước đó.\n Waterfall_model \n※Hãy biết cả điều này nữa\n*Chi phí (cost) cần để sửa chữa* Trong phát triển theo mô hình Waterfall model, nếu test vận hành mà phát hiện ra sai sót, thì chi phí cần để sửa chữa sẽ rất cao, đến mức nguyên nhân là do công đoạn thượng nguồn trong quá trình phát triển  Prototyping model Phương pháp tạo sản phẩm thử nghiệm (Prototype) từ đầu, rồi nhờ người sử dụng (người đặt hàng) kiểm tra hiệu quả hay tính hữu dụng và tiến hành phát triển song song được gọi là Prototyping model. Dẫu có hiểu sai, hiểu nhầm giữa người đặt hàng và người phát triển, thì vẫn có thể xác nhận và chỉnh sửa từ sớm, nên có thể giảm thiểu sai sót hay quay trở lại phát triển.\nSpiral model Khi qua đến hệ thống có quy mô lớn, thì tiến hành làm tất cả hệ thống theo quy trình Waterfall model sẽ rất vất vả, và tạo Prototype cũng không đơn giản. Trong những trường hợp như vậy, người ta sẽ chia hệ thống ra thành một vài hệ thống con (subsystem), tiến hành phát triển theo Spiral model lặp lại các vòng tròn (cycle) phát triển. Các hệ thống con đã hoàn thiện thì sẽ tạo Prototype để nhờ người dùng đánh giá, rồi lấy đó làm bộ phận để phát triển hệ thống con lớn hơn nữa. Quá trình làm như vậy để rồi các hệ thống con dần dần lớn lên làm ta hình dung tới xoắn ốc (spiral), nên nó được gọi là Spiral model.\n Spiral_model \n※Hãy biết cả điều này nữa\n*Phát triển Agile* Agile có nghĩa là \u0026quot;Mang tính nhanh nhạy\u0026quot;. Đây là phương pháp phát triển theo kiểu phái sinh từ Spiral model, vừa lặp lại vòng tròn (cycle) phát triển trong thời gian ngắn theo đơn vị tuần, vừa hoàn thiện các chức năng theo giai đoạn. Nó có ưu điểm là rút ngắn thời gian phát triển, có thể xử lý đối phó linh hoạt đối với những thay đổi về spec.  ※Chỗ này thường ra này!\n*Thuật ngữ* [ウォータフォールモデル] (Waterfall model): phát triển theo thứ tự Định nghĩa yêu cầu → Thiết kế hệ thống → Lập trình → Test [プロトタイピング] (Prototyping): vừa tạo sản phẩm thử nghiệm vừa phát triển [スパイラルモデル] (Spiral model): lặp lại các development cycle để phát triển  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 21) Giải thích cho Waterfall model trong phát triển hệ thống là cái nào dưới đây ア: Không đi tạo tất cả trong 1 lần phát triển, mà phát triển theo từng giai đoạn ứng với độ ưu tiên của chức năng, trên cơ sở kiến trúc hệ thống cơ bản イ: Chia công đoạn phát triển ra thành Thiết kế, Implement, Test,..., khi hoàn thành công đoạn trước thì dùng thành quả đó để thực hiện công đoạn tiếp theo ウ: Tạo sản phẩm thử nghiệm, feeback (phản hồi) yêu cầu của người dùng để tiến hành phát triển エ: Không cố tạo toàn bộ phần mềm phức tạp từ đầu, mà tiến hành lặp lại các bước Phân tích, Thiết kế, Implement, Test từ những phần đơn giản, rồi từ từ mở rộng ra → Answer: イ Giải thích: Waterfall model là phương pháp phát triển chia các công đoạn phát triển ra thành Thiết kế, Implement, Test,..., và tiến hành làm theo thứ tự này.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination Mùa thu năm Heisei 23) Phương pháp phát triển phần mềm vừa lặp lại quy trình phát triển từ phân tích yêu cầu đến implement, vừa đi xây dụng nên hệ thống là cái nào dưới đây ア: Waterfall model イ: Spiral model ウ: Prototyping model エ: Relational model → Answer: イ Giải thích: Phương pháp phát triển xây dựng nên hệ thống bằng cách lặp lại vòng tròn phát triển là Spiral model ","date":"2021-04-10T17:00:00+07:00","permalink":"https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-2-c%C3%A1c-ph%C6%B0%C6%A1ng-ph%C3%A1p-ph%C3%A1t-tri%E1%BB%83n-h%E1%BB%87-th%E1%BB%91ng/","title":"FE Book_Chapter 5: System development_Lesson 5-2: Các phương pháp Phát triển hệ thống"},{"content":"Quy trình phát triển hệ thống Hệ thống là cơ cấu kết hợp phần cứng và phần mềm, để chúng xử lý giúp ta những công việc nhất định nào đó. Có nhiều hệ thống khác nhau xung quanh chúng ta, ví dụ như hệ thống ATM ngân hàng, hay hệ thống đặt chỗ ngồi trên máy bay. Máy tính được sử dụng cho hệ thống không nhất thiết chỉ có 1 cái. Cũng có những hệ thống quy mô lớn, kết nối cả một mạng lưới nhiều máy tính.\nTa nhận yêu cầu từ bên đặt hàng, lên kế hoạch, thiết kế và phát triển hệ thống tùy theo yêu cầu. Sau khi hoàn thành ổn thỏa, sẽ vừa vận hành vừa bảo trì định kỳ, hết nhiệm vụ thì hủy bỏ. Có một quy trình xuyên suốt từ khi lên kế hoạch đến khi hủy bỏ trong hệ thống như vậy, nó được gọi là System Life Cycle\nTrong chương này, ta sẽ đi tìm hiểu chi tiết xem, việc phát triển hệ thống được thực hiện như thế nào. Các bước được thực hiện trong quá trình phát triển theo như flow dưới đây:\n Development_flow \nỞ các bước trong quy trình này, ta thực hiện những việc dưới đây:\nĐịnh nghĩa yêu cầu Ở công đoạn đầu tiên trong phát triển hệ thống, dựa vào request từ bên đặt hàng là \u0026ldquo;Chúng tôi muốn có cái hệ thống có thể làm được những việc như thế này, để phục vụ cho mục đích như vầy\u0026rdquo;, ta sẽ đi phân tích nghiệp vụ hiện tại, sắp xếp điều chỉnh lại yêu cầu hệ thống.\n※Hãy biết cả điều này nữa\n*Yêu cầu phi chức năng (非機能要件)* Trong định nghĩa yêu cầu, ngoài những yêu cầu chức năng định nghĩa các chức năng cần thiết cho hệ thống, thì ta cũng định nghĩa cả những yêu cầu phi chức năng nữa. Ta sẽ làm rõ những yêu cầu chất lượng, yêu cầu kỹ thuật, yêu cầu vận hành/ thao tác... cần thiết để hiện thực hóa yêu cầu nghiệp vụ. Ví dụ như là tạo tiêu chuẩn phát triển phù hợp theo ngôn ngữ lập trình đang được sử dụng trong phát triển hệ thống.  Thiết kế hệ thống Ta sẽ thiết kế hệ thống dựa theo định nghĩa yêu cầu. Ở bước thiết kế hệ thống, ta sẽ suy nghĩ những phần cứng và phần mềm cần thiết để đạt được mục đích hay chức năng của hệ thống sẽ là gì, rồi vẽ sơ đồ bố trí hay viết bản kế hoạch thể hiện việc sẽ kết hợp chúng lại như thế nào.\nTrong thiết kế phần mềm, việc thực hiện đầu tiên sẽ là Định nghĩa yêu cầu phần mềm (External design) - ソフトウェア要件定義 (外部設計). Ta sẽ đi thiết kế dữ liệu logic, ví dụ như là thiết kế phần bề ngoài của hệ thống như màn hình nhập\u0026hellip;, hay lọc ra những mục dữ liệu cần thiết cho hệ thống, rồi quyết định cấu trúc hệ thống.\nTiếp theo sẽ là Software architecture design (Internal design) - ソフトウェア方式設計 (内部設計). Dựa vào yêu cầu phần mềm đã quyết định ở công đoạn trước đó, ta sẽ thiết kế cơ cấu bên trong, đó là quyết định chu trình xử lý hay các chức năng tích hợp vào. Cuối cùng là Thiết kế chi tiết phần mềm (Detailed design) - ソフトウェア詳細設計 (詳細設計), ta sẽ đi thiết kế cấu trúc program. Để dễ dàng phân chia công việc và thực hiện lập trình, phần đông mọi người sẽ chia ra và thiết kế program đến mức đơn vị chi tiết hơn nữa gọi là module.\nLập trình Dựa theo tài liệu thiết kế, tiến hành lập trình (coding), hoàn thiện các module.\nTest Tiến hành test theo giai đoạn, xem đơn lẻ các module, tổng thể phần mềm kết hợp các module lại có hoạt động theo đúng tài liệu thiết kế hay không.\nChấp nhận phần mềm Đưa vào sử dụng phần mềm trên môi trường phần cứng giống với khi vận hành thực tế, kiểm tra xem nó có hoạt động đúng hay không. Việc kiểm tra này sẽ do bên người đặt hàng thực hiện. Tuy nhiên, bên nhà cung cấp bán dịch vụ (phần mềm) cũng hỗ trợ nhiều thứ để có thể tiếp nhận được suôn sẻ, ví dụ như giải thích về cách sử dụng cho bên đặt hàng\u0026hellip;\n※Chỗ này thường ra này!\n*Thuật ngữ* [非機能要件] (Yêu cầu phi chức năng): làm rõ các yêu cầu chất lượng, kỹ thuật, vận hành, thao tác cần thiết để hiện thực hóa yêu cầu nghiệp vụ. Ví dụ như là tạo tiêu chuẩn phát triển... [ソフトウェア方式設計 (内部設計] (Software architecture design (Internal design)): thiết kế cơ cấu bên trong, xem sẽ hiện thực hóa yêu cầu phần mềm đã quyết định ở công đoạn trước đó như thế nào *Skill* → Hãy hiểu được quy trình tổng thể, rằng ở các công đoạn trong các bước phát triển thì ta sẽ quyết định những gì và thực hiện những gì.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination　Mùa xuân năm Heisei 21) Đáp án nào dưới đây là phù hợp khi nói về công việc thực hiện ở công đoạn đầu tiên trong phát triển hệ thống? ア: Thiết kế cấu trúc bên trong của các program イ: Phân tích nghiệp vụ hiện tại, sắp xếp chỉnh lý yêu cầu hệ thống ウ: Chia nhỏ sub system đến đơn vị program, thiết kế chi tiết các program エ: Thiết kế user interface → Answer: イ Giải thích: Khi phát triển hệ thống, việc thực hiện đầu tiên đó là Định nghĩa yêu cầu, đi phân tích nghiệp vụ hiện tại, sắp xếp lại xem mình sẽ phát triển hệ thống như thế nào.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination　Mùa thu năm Heisei 25) Giải thích cho định nghĩa yêu cầu phi chức năng là cái nào dưới đây? ア: Làm rõ các chức năng nghiệp vụ sẽ khó hiện thực hóa trên hệ thống, phải làm thủ công trong số các yêu cầu nghiệp vụ イ: Làm rõ các yêu cầu chất lượng, yêu cầu kỹ thuật, yêu cầu vận hành... cần thiết để hiện thực hóa yêu cầu nghiệp vụ ウ: Làm rõ các chức năng bị thiếu ở hệ thống hiện hành, để xác định được yêu cầu nghiệp vụ エ: Làm rõ tính tương thích của package đưa vào sử dụng mới, để hiện thực hóa yêu cầu nghiệp vụ → Answer: イ Giải thích: Ở yêu cầu phi chức năng, ta sẽ làm rõ những yêu cầu chất lượng, kỹ thuật, vận hành, thao tác... cần thiết để hiện thực hóa yêu cầu nghiệp vụ.  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination　Mùa xuân năm Heisei 25) Công việc cần phải làm ở ソフトウェア方式設計 (Software architecture design) trong quy trình phát triển là cái nào dưới đây? ア: Hỏi ý kiến khách hàng rồi quyết định spec イ: Quyết định sẽ hiện thực hóa yêu cầu phần mềm đã chốt trước đó như thế nào ウ: Chi tiết hóa để rõ ràng đến xử lý theo từng dòng program エ: Tổng hợp nội dung yêu cầu thành biểu đồ, bảng biểu,..., từng bước chi tiết hóa rồi phân tích → Answer: イ Giải thích: Ở ソフトウェア方式設計 (Software architecture design), ta sẽ quyết định kết hợp và hiện thực hóa phần mềm như thế nào  *Note:\n1/ ソフトウェア方式設計 là khái niệm chỉ có của Nhật. Mình đã thử search từ khóa tiếng Anh với ý nghĩa tương đồng, nhưng không có.\nCó vẻ như họ định nghĩa 方式設計 là một phần trong khâu 基本設計 (Basic design)\n基本設計 (Basic design) trong Hệ thống thông tin xuất phát từ 機能設計 (Functional design) - thứ định nghĩa \u0026ldquo;方式設計\u0026rdquo; quyết định cấu trúc (architect) phần cứng/ phần mềm và phương châm implement VÀ 外部仕様 (External specification) của hệ thống khi nhìn từ quan điểm của user (chức năng, màn hình, form nhập, dữ liệu).\nNgoài ra, cũng thực hiện thiết kế hiệu năng, độ tin cậy, hay thiết kế bảo mật, thiết kế migration, thiết kế operation\u0026hellip;　Reference: https://blogs.itmedia.co.jp/omowaku/2007/10/post_129a.html\n2/ Có một cách chia khác về giai đoạn thiết kế trong quá trình phát triển hệ thống, sau khi định nghĩa yêu cầu (要件定義).\nĐó là: 基本設計・外部設計 (Basic design/ External design) → 詳細設計・内部設計 (Detailed design/ Internal design)\nTrong Basic design/ External design lại chia ra làm 3 loại nhỏ hơn nữa là 方式設計, 機能設計 và その他の設計\n  方式設計 (アーキテクチャ設計):\nQuyết định cấu trúc phần cứng/ phần mềm, phương châm implement\n→ Thiết kế Platform (Quyết định Infra, Middleware, Platform, Framework\u0026hellip;)\n→ Thiết kế Application, Architecture (Quyết định cấu trúc tổng thể của application)\n→ Quyết định tiêu chuẩn phát triển hay cách thức test\n  機能設計 (アプリケーション設計)\nChia tổng thể hệ thống ra thành đơn vị module, quyết định external spec cho các module\n→ Thiết kế Business logic\n→ Thiết kế Database\n→ Thiết kế màn hình, form nhập\n→ Thiết kế batch\n  その他の設計\n→ Thiết kế hiệu năng, tính tin cậy\n→ Thiết kế migration (hệ thống/ nghiệp vụ)\n→ Thiết kế operation (hệ thống/ nghiệp vụ)\n  Trong Detailed design/ Internal design thì có\n Phân chia chức năng Thiết kế physical data Thiết kế chi tiết input, output  Reference:\nhttps://qiita.com/mikakane/items/b8045a11dba8d08e5fe4\nhttps://tiengnhatmuonmau.com/post/622\n3/ Basic Design, Detailed design cũng là Wasei-eigo!!! Xem bài viết trước đây về 和製英語\nỞ trên, ta có bắt gặp khái niệm 方式設計, tương tự với khái niệm này thì trong tiếng Nhật cũng có các từ như アーキテクチ設計, 概要設計, dịch ra tiếng Anh là Architecture design. Ở Mỹ thì từ tương ứng sẽ là High-level design\n基本設計 dịch thẳng ra là Basic design, nhưng đây cũng là một từ Wasei-eigo. Các nước nói tiếng Anh không sử dụng từ như vậy. Từ sát nghĩa nhất sẽ là Functional Design (mô tả program cần làm những gì)\n詳細設計 thì có lẽ cụm từ thích hợp nhất tương ứng trong tiếng Anh sẽ là Technical design (mô tả chức năng sẽ được implement như thế nào ở level code)\nReference: http://americanprojectmanagement.blogspot.com/2017/06/basic-design.html\n","date":"2021-03-28T17:00:00Z","permalink":"https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-1-kh%C3%A1i-qu%C3%A1t-v%E1%BB%81-ph%C3%A1t-tri%E1%BB%83n-h%E1%BB%87-th%E1%BB%91ng/","title":"FE Book_Chapter 5: System development_Lesson 5-1: Khái quát về Phát triển hệ thống"},{"content":"Computer là gì? Ngày nay, Computer (máy tính) được sử dụng trong hầu hết các thiết bị điện tử thông dụng như PC, máy chơi game, điện thoại di động,\u0026hellip;\nVậy thì, vốn dĩ Computer là gì?\nComputer là cỗ máy làm thay cho con người chúng ta nhiều việc như thực hiện tính toán số lượng lớn, hay xử lý những dữ liệu phức tạp,\u0026hellip; Nhờ có máy tính, chúng ta tác nghiệp dễ dàng hơn, xử lý công việc một cách hiệu quả.\nHardware và Software Yếu tố cấu thành máy tính được chia ra làm 2 loại lớn là Hardware (phần cứng) và Software (phần mềm). Để máy tính hoạt động được, cần phải có cả hai thứ này.\nPhần cứng là những thứ mang tính vật chất như màn hình, bàn phím. Phần mềm là chương trình hoạt động bên trong máy tính.\nCác loại phần cứng Trước tiên, ta sẽ đi vào giải thích về phần cứng.\nMáy tính cần có 5 loại phần cứng là: thiết bị nhập vào, thiết bị ghi nhớ, thiết bị điều khiển, thiết bị tính toán và thiết bị xuất ra.\nCác loại phần cứng\n   Thiết bị Vai trò Ví dụ     Thiết bị nhập vào Kết nối với phần chính của máy tính, nhập vào dữ liệu hay chương trình Bàn phím, chuột   Thiết bị ghi nhớ Lưu lại dữ liệu hay chương trình đã được nhập vào. Thường đặt ở bên trong phần chính của máy tính Bộ nhớ, ổ đĩa cứng   Thiết bị điều khiển Lấy mệnh lệnh chương trình từ thiết bị ghi nhớ ra rồi diễn giải, điều khiển những phần cứng khác CPU   Thiết bị tính toán Theo mệnh lệnh của chương trình, thực hiện tính toán đối với những dữ liệu đã lấy ra từ thiết bị ghi nhớ CPU   Thiết bị xuất ra Hiển thị, in ra cho con người có thể thấy được những dữ liệu đã được tính toán bên trong phần chính của máy tính Màn hình, máy in    Dưới đây là sơ đồ diễn tả dữ liệu di chuyển như thế nào giữa 5 thiết bị  Data flow \nNguyên lý hoạt động của máy tính Máy tính ngày nay là do nhà toán học người Mỹ Neumann đề xướng, có những đặc điểm sau đây:\nPhương thức chứa program Là phương thức nạp trước chương trình (program) vào bộ nhớ chính, CPU sẽ vừa gọi ra vừa chạy lần lượt. Có thể thay đổi cả xử lý chạy nếu thay đổi chương trình bằng cách cho chương trình độc lập với phần cứng. Phương thức có lưu sẵn chương trình cũng được gọi là phương thức ghi nhớ chương trình (Stored program method)\n※Chỗ này thường ra này!\n*Thuật ngữ* [プログラム格納方式] (Stored program method): nạp chương trình vào bộ nhớ chính, CPU vừa gọi ra vừa chạy lần lượt  ※Thử thách với bài test\n(Fundamental Information Technology Engineer Examination　Mùa xuân năm Heisei 26) Phương thức CPU vừa gọi ra vừa chạy lần lượt chương trình đã được ghi vào bộ nhớ chính là gì? ア: 制御方式 イ: アドレス指定方式 ウ: 仮想記憶方式 エ: プログラム格納方式 → Answer: エ  ","date":"2021-03-27T22:30:00Z","permalink":"https://sakazutoshi.com/p/fe-book_chapter-1-hardware_lesson-1-1-hardware/","title":"FE Book_Chapter 1: Hardware_Lesson 1-1: Hardware"},{"content":" Wasei Eigo \nSử dụng tiếng Nhật để làm việc trong ngành IT, chắc hẳn bạn sẽ dễ dàng nhận ra một đặc thù: có rất nhiều từ vựng chuyên ngành là từ Katakana. Hầu hết chúng đều bắt nguồn từ tiếng Anh. Và thông thường thì giữ nguyên tiếng Anh, không cố dịch ra tiếng Việt là lựa chọn khôn ngoan nhất.\nTuy nhiên, khác với Gairaigo (外来語) - những từ ngoại lai được vay mượn trực tiếp từ ngôn ngữ nước ngoài và “may mắn” còn giữ được nguyên ngữ nghĩa của chúng khi “nhập khẩu”, thì người Nhật còn xào nấu tiếng Anh để sáng tạo nên một lớp từ vựng kiểu mới, nhìn thì có vẻ giống tiếng Anh đấy, nhưng thực chất thì nghĩa đã bị thay đổi từ một phần cho đến hoàn toàn so với nghĩa gốc ban đầu - chúng được gọi là Wasei-eigo (和製英語).\nLẽ dĩ nhiên, nếu người Nhật sử dụng y nguyên những từ Wasei-eigo này để giao tiếp với người nói tiếng Anh, thì người nghe cũng không thể nào hiểu được. Và với vai trò là cầu nối giữa hai bên Nhật - Việt, một IT Communicator cần phải chú ý khi gặp những từ vựng kiểu này, để có cách dịch chính xác và tự nhiên nhất. Hôm nay, mình sẽ giới thiệu một số từ Wasei-eigo thường được sử dụng trong ngành IT, và cách diễn đạt chúng trong tiếng Anh/ tiếng Việt nhé.\nMục lục\n [バージョンアップ (Version up)・バージョンダウン (Version down)](#バージョンアップ-(Version up)・バージョンダウン-(Version down)) デグレーション・デグレード・デグレ (Degradation, Degrade) サービスイン (Service in) カットオーバー (Cut over) システムダウン (System down) アンダーバー (Underbar) チャージ (Charge)  バージョンアップ (Version up)・バージョンダウン (Version down) Khi một từ Wasei-eigo có chữ \u0026ldquo;up\u0026rdquo; hay “down” đứng sau, nó có nghĩa là \u0026ldquo;tăng lên\u0026rdquo;, \u0026ldquo;cải thiện\u0026rdquo; hay “làm giảm”, “hạ xuống” thứ gì đó. Vì vậy, có thể dễ dàng đoán được Version up nghĩa là nâng cấp phần mềm lên phiên bản mới hơn, Version down nghĩa là hạ phần mềm xuống lại phiên bản cũ hơn.\nCó nhiều người vẫn giữ nguyên như vậy khi dịch qua tiếng Anh, tuy nhiên thật sự thì đây là một từ Wasei-eigo, và trong tiếng Anh không tồn tại cách nói như vậy.\nTrong tiếng Anh, khái niệm này được gọi là \u0026ldquo;Upgrade (version)\u0026rdquo;, \u0026ldquo;Downgrade (version)\u0026rdquo;.\nEx:\nお使いのブラウザを最新版にバージョンアップしてください。\nPlease upgrade your browser to the latest version.\nバージョンダウンすることによってレイアウトや見た目が変わる場合があります。\nCó trường hợp layout hay bề ngoài sẽ thay đổi do downgrade\nデグレーション・デグレード・デグレ (Degradation, Degrade) Việc xuất hiện bug khác do ảnh hưởng khi thay đổi, chỉnh sửa một phần nào đó trong program, khiến chất lượng sản phẩm còn tệ hơn trước đó trong tiếng Nhật được gọi là \u0026ldquo;デグレード\u0026rdquo;, nói gọn lại là \u0026ldquo;デグレ\u0026rdquo; (Degrade).\nĐể dễ hiểu hơn, bạn cứ tưởng tượng như thế này: lúc lập trình, xuất hiện tình trạng chức năng rõ ràng đã implement ok rồi mà giờ lại bị mất đi/ không hoạt động được, hay cái bug rõ ràng là đã loại bỏ đi rồi thì giờ lại xuất hiện lại.\nNgoài ra, việc kiểm thử được thực hiện để đảm bảo xem có xảy ra tình trạng như vậy hay không được gọi là \u0026ldquo;デグレードテスト\u0026rdquo; (Degrade test), \u0026ldquo;ノンデグレードテスト\u0026rdquo; (Non derade test)\u0026hellip;\nTuy nhiên, từ \u0026ldquo;デグレード\u0026rdquo; này là một từ Wasei-eigo chỉ có thể hiểu được khi dùng trong ngành IT của Nhật thôi.\nTrong tiếng Anh, hiện tượng như trên được gọi là \u0026ldquo;Regression\u0026rdquo;, và việc kiểm thử hiện tượng đó được gọi là \u0026ldquo;Regression testing\u0026rdquo;.\nTừ \u0026ldquo;Degrade\u0026rdquo; trong tiếng Anh là một động từ mang ý nghĩa làm giảm giá trị, làm giảm chất lượng, nên cách sử dụng trong ngữ cảnh như trên cũng không hợp lý nhỉ.\nThêm nữa, cũng có khi ta bắt gặp từ \u0026ldquo;デグレーション\u0026rdquo;, nhưng trong tiếng Anh thì danh từ của \u0026ldquo;degrade\u0026rdquo; là \u0026ldquo;degradation\u0026rdquo;, chứ không hề tồn tại từ \u0026ldquo;degration\u0026rdquo;.\nEx:\nソフトウェアの修正を行うたびに、デグレードテストを実施しなければなりません。 Phải thực hiện regression test mỗi khi chỉnh sửa phần mềm.\n※Thông tin thêm: Có người còn chia デグレード ra hai loại như sau:\n  \u0026ldquo;先祖返り\u0026rdquo; (せんぞがえり)\nKhi upgrade version, chức năng vốn đã sửa rồi lại quay trở về version trước đó.\nNói một cách cụ thể hơn về khái niệm này là: do có sai sót, nhầm lẫn trong việc quản lý version, mà chức năng chắc chắn đã làm thêm rồi giờ bị biến mất, hay cái bug vốn đã fix rồi giờ lại bị lại.\n  \u0026ldquo;エンバグ\u0026rdquo; (Enbug)\nDo thay đổi source code để fix bug hay thêm chức năng mà lại tạo ra bug khác trước giờ chưa có được gọi là \u0026ldquo;エンバグ\u0026rdquo;.\nTừ \u0026ldquo;エンバグ\u0026rdquo; này cũng giống với \u0026ldquo;デグレード\u0026rdquo;, là một Wasei-eigo, nên đây là cách nói không tồn tại trong tiếng Anh.\nVì đây là sai sót khác với \u0026ldquo;リグレッション (Regression)\u0026rdquo; mang nghĩa \u0026ldquo;退行 - Giật lùi, đi ngược trở lại\u0026rdquo;, nên cũng có người phân biệt từ này với \u0026ldquo;デグレード\u0026rdquo;\n  サービスイン (Service in) Việc hệ thống mới bắt đầu đi vào hoạt động chính thức được gọi là \u0026ldquo;サービスイン\u0026rdquo;, nhưng trong tiếng Anh, nếu dùng từ này thì người ta sẽ không hiểu.\nTừ tương ứng với nghĩa này trong tiếng Anh là \u0026ldquo;go-live\u0026rdquo;. Là danh từ thì có dấu gạch ngang ở giữa. Còn động từ thì có thể dùng \u0026ldquo;go live\u0026rdquo;.\nNgoài ra, cũng có thể sử dụng từ \u0026ldquo;release\u0026rdquo; hay \u0026ldquo;launch\u0026rdquo; với nghĩa tương tự.\nEx: このシステムは来月サービスインする予定です。\nThis system will go live next month.\nカットオーバー (Cut over) \u0026ldquo;カットオーバー\u0026rdquo; cũng được sử dụng với nghĩa gần như tương tự với từ \u0026ldquo;サービスイン\u0026rdquo; phía trên, nên ta có thể sử dụng \u0026ldquo;go-live\u0026rdquo;, \u0026ldquo;release\u0026rdquo;, \u0026ldquo;launch\u0026rdquo; để thể hiện ý nghĩa này.\nTrong tiếng Anh cũng có từ \u0026ldquo;cut over\u0026rdquo;, nhưng ý nghĩa hơi khác một chút. Trong khi \u0026ldquo;カットオーバー\u0026rdquo; trong tiếng Nhật chỉ thời điểm bắt đầu hoạt động hệ thống mới, thì \u0026ldquo;cut over\u0026rdquo; trong tiếng Anh là từ chỉ \u0026ldquo;giai đoạn chuyển từ hệ thống cũ sang hệ thống mới\u0026rdquo;.\nTrong khi từ \u0026ldquo;カットオーバー\u0026rdquo; trong tiếng Nhật thường dùng để chỉ \u0026ldquo;go-live\u0026rdquo; trong tiếng Anh, thì \u0026ldquo;cut over\u0026rdquo; trong tiếng Anh lại mang ý nghĩa là giai đoạn trước đó, nên khi trao đổi bằng tiếng Anh thì cần phải chú ý.\nシステムダウン (System down) Việc hệ thống bị dừng hoạt động hay tắt bất thường, ngoài mong muốn được gọi là \u0026ldquo;システムダウン\u0026rdquo;. Trong tiếng Việt, chúng ta dùng cách nói \u0026ldquo;sập hệ thống\u0026rdquo;, còn trong tiếng Anh thì không có cách diễn đặt bằng danh từ kiểu như \u0026ldquo;system down\u0026rdquo; như vậy.\nTrong tiếng Anh, thường sử dụng cách nói \u0026ldquo;system failure\u0026rdquo; hay \u0026ldquo;system crash\u0026rdquo;.\nEx: システムダウンによりご不便をおかけして申し訳ございません。\nWe apologize for any inconvenience caused by the system failure.\nCòn khi sử dụng từ \u0026ldquo;down\u0026rdquo;, thì sẽ diễn đạt theo kiểu \u0026ldquo;động từ tobe + down\u0026rdquo; hay \u0026ldquo;go down\u0026rdquo;.\n昨日から在庫管理システムがダウンしています。 The inventory management system has been down since yesterday.\n停電のため、コンピュータシステムがダウンしました。 Our computer system went down due to a power outage.\nアンダーバー (Underbar) Dấu gạch dưới \u0026ldquo;_\u0026rdquo; trong tiếng Nhật thường được gọi là \u0026ldquo;アンダーバー\u0026rdquo;, nhưng trong tiếng Anh thì gọi là \u0026ldquo;Underscore\u0026rdquo;.\nEx:\nドメイン名にアンダーバーを使うことはできません。 You can’t use an underscore in the domain name.\niPadでアンダーバー記号を入力するにはどうすればよいですか？ How can I type an underscore symbol on iPad?\nチャージ (Charge) Ở Nhật, người ta dùng khái niệm \u0026ldquo;チャージ\u0026rdquo; khi nạp tiền vào thẻ PASMO, SUICA,\u0026hellip; Trong tiếng Việt, chúng ta cũng hay dùng cách nói tương tự là \u0026ldquo;charge tiền\u0026rdquo; đúng không nào? Nhưng thật sự thì trong tiếng Anh, họ không dùng từ charge để chỉ việc nạp tiền, tăng số dư trong thẻ đâu. Trong tiếng Anh, khái niệm này được diễn đạt bằng từ \u0026ldquo;refill\u0026rdquo; hoặc \u0026ldquo;top-up\u0026rdquo;.\nEx: PASMOカードは何度でも繰り返し入金できます。\nYou can refill your PASMO card as many times as desired.\nVẫn còn rất rất nhiều từ Wasei-eigo nữa, mình không thể nào liệt kê hết được (thậm chí, có rất nhiều từ mà người Nhật cũng không biết chúng là Wasei-eigo đâu).\nMỗi dự án chúng ta làm đều có những từ vựng riêng ứng với chuyên ngành, nghiệp vụ mà hệ thống đó phục vụ. Vì vậy, nếu có bắt gặp những từ vựng mới là Katakana, thì đừng vội vàng dịch chúng ra ngay, mà hãy cẩn thận tìm hiểu, rồi đưa ra cách dịch đúng, phù hợp nhất nhé ^^\n","date":"2021-03-20T23:50:00Z","permalink":"https://sakazutoshi.com/p/h%C3%A3y-c%E1%BA%A9n-th%E1%BA%ADn-v%E1%BB%9Bi-wasei-eigo-ti%E1%BA%BFng-anh-ch%E1%BA%BF-c%E1%BB%A7a-ng%C6%B0%E1%BB%9Di-nh%E1%BA%ADt/","title":"Hãy cẩn thận với Wasei-Eigo - tiếng Anh chế của người Nhật"}]