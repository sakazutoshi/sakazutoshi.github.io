<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Lập trình là gì? Người ta dùng ngôn ngữ chuyên dụng để tạo nên chương trình theo đơn vị module đã chia ở bước thiết kế chi tiết phần mềm. Công việc tạo lập này được gọi là Lập trình - Programming (Coding)
※Hãy biết cả điều này nữa
*Tiêu chuẩn hóa lập trình* Việc quyết định quy tắc nhất định như đặt tên biến hay comment... với mục đích khiến cho nội dung xử lý của chương trình trở nên dễ hiểu được gọi là *Tiêu chuẩn hóa lập trình*."><title>FE Book_Chapter 5: System development_Lesson 5-6: Lập trình</title>
<link rel=canonical href=https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="FE Book_Chapter 5: System development_Lesson 5-6: Lập trình">
<meta property="og:description" content="Lập trình là gì? Người ta dùng ngôn ngữ chuyên dụng để tạo nên chương trình theo đơn vị module đã chia ở bước thiết kế chi tiết phần mềm. Công việc tạo lập này được gọi là Lập trình - Programming (Coding)
※Hãy biết cả điều này nữa
*Tiêu chuẩn hóa lập trình* Việc quyết định quy tắc nhất định như đặt tên biến hay comment... với mục đích khiến cho nội dung xử lý của chương trình trở nên dễ hiểu được gọi là *Tiêu chuẩn hóa lập trình*.">
<meta property="og:url" content="https://sakazutoshi.com/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/">
<meta property="og:site_name" content="Sakura Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="system_development"><meta property="article:published_time" content="2021-09-23T20:00:00+07:00"><meta property="article:modified_time" content="2021-09-23T20:00:00+07:00">
<meta name=twitter:title content="FE Book_Chapter 5: System development_Lesson 5-6: Lập trình">
<meta name=twitter:description content="Lập trình là gì? Người ta dùng ngôn ngữ chuyên dụng để tạo nên chương trình theo đơn vị module đã chia ở bước thiết kế chi tiết phần mềm. Công việc tạo lập này được gọi là Lập trình - Programming (Coding)
※Hãy biết cả điều này nữa
*Tiêu chuẩn hóa lập trình* Việc quyết định quy tắc nhất định như đặt tên biến hay comment... với mục đích khiến cho nội dung xử lý của chương trình trở nên dễ hiểu được gọi là *Tiêu chuẩn hóa lập trình*.">
<link rel="shortcut icon" href=/favicon.ico>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://sakazutoshi.com class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/fe_book/>
FE_Book
</a>
</header>
<h2 class=article-title>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/>FE Book_Chapter 5: System development_Lesson 5-6: Lập trình</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Sep 23, 2021</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
9 min read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h3 id=lập-trình-là-gì>Lập trình là gì?</h3>
<p>Người ta dùng ngôn ngữ chuyên dụng để tạo nên chương trình theo đơn vị module đã chia ở bước thiết kế chi tiết phần mềm. Công việc tạo lập này được gọi là Lập trình - Programming (Coding)</p>
<p>※<em>Hãy biết cả điều này nữa</em></p>
<pre><code>*Tiêu chuẩn hóa lập trình*
Việc quyết định quy tắc nhất định như đặt tên biến hay comment... 
với mục đích khiến cho nội dung xử lý của chương trình trở nên dễ hiểu 
được gọi là *Tiêu chuẩn hóa lập trình*. Nó có hiệu quả là giúp chương trình 
dễ đọc, phòng ngừa trước những lỗi mà lập trình viên dễ phạm phải.
</code></pre>
<h3 id=ngôn-ngữ-lập-trình>Ngôn ngữ lập trình</h3>
<p>Ngôn ngữ chuyên dụng để viết chương trình được gọi là <em>Ngôn ngữ lập trình</em>. Có nhiều loại khác nhau trong ngôn ngữ lập trình. Ngôn ngữ lập trình mà máy tính dễ hiểu hơn được gọi là <em>Ngôn ngữ bậc thấp</em>, ngôn ngữ lập trình dễ hiểu đối với con người được gọi là <em>Ngôn ngữ bậc cao</em>.
Trong ngôn ngữ bậc thấp có các loại như ngôn ngữ máy, ngôn ngữ Assembly&mldr; Ngược lại, trong ngôn ngữ bậc cao có COBOL, FORTRAN, C, BASIC, Pascal, C++, Java&mldr;</p>
<h3 id=language-processor-bộ-xử-lý-ngôn-ngữ>Language processor (Bộ xử lý ngôn ngữ)</h3>
<p>Máy tính chỉ có thể hiểu được chương trình viết bằng ngôn ngữ máy. Do đó, <em>Chương trình gốc</em> (Source program) là chương trình do con người mô tả không thể nào giữ nguyên như thế mà chạy trên máy tính được. Vì vậy, cần sử dụng chương trình dịch gọi là <em>Language processor</em> để dịch ra <em>Chương trình đích</em> là chương trình ngôn ngữ máy.</p>
<p><figure style=flex-grow:341;flex-basis:818px>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-role.png data-size=2388x700><img src=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-role.png srcset="/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-role_hu666aa1d8cb7532ffbd89687a5dc6bf6c_221718_480x0_resize_box_3.png 480w, /p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-role_hu666aa1d8cb7532ffbd89687a5dc6bf6c_221718_1024x0_resize_box_3.png 1024w" width=2388 height=700 loading=lazy>
</a>
</figure></p>
<p>Tùy theo cách dịch mà có thể phân loại Language processor ra thành <em>Assembler</em>, <em>Compiler</em>, <em>Generator</em>, <em>Interpreter</em></p>
<p><figure style=flex-grow:174;flex-basis:419px>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-types.png data-size=2010x1150><img src=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-types.png srcset="/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-types_hu65ada2d1ef66add98fe6e07ac33b4364_249744_480x0_resize_box_3.png 480w, /p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/language-processor-types_hu65ada2d1ef66add98fe6e07ac33b4364_249744_1024x0_resize_box_3.png 1024w" width=2010 height=1150 loading=lazy>
</a>
</figure></p>
<h4 id=assembler>Assembler</h4>
<p><em>Assembler</em> là Language processor dịch chương trình gốc được viết bằng ngôn ngữ Assembly sang chương trình đích. Ngôn ngữ Assembly phân chia ký hiệu ra thành ngôn ngữ máy, lệnh được dịch sang ngôn ngữ máy theo nguyên tắc 1-1. Việc dịch bằng Assembler được gọi là <em>Assemble</em>.</p>
<h4 id=compiler>Compiler</h4>
<p><em>Compiler</em> là Language processor tổng hợp lại một lần chương trình gốc được viết bằng ngôn ngữ bậc cao rồi mới dịch sang chương trình đích. Việc dịch bằng compiler được gọi là <em>Compile</em></p>
<h4 id=generator>Generator</h4>
<p><em>Generator</em> là Language processor tự động generate ra chương trình ứng với mục đích xử lý, bằng cách chỉ thị những điều kiện cần thiết như nhập vào, xử lý, xuất ra,&mldr; bằng parameter là giá trị setting.</p>
<h4 id=interpreter>Interpreter</h4>
<p><em>Interpreter</em> là Language processor diễn giải rồi chạy từng dòng một chương trình được viết bằng ngôn ngữ bậc cao. Do không tạo ra chương trình đích với ngôn ngữ máy, nên cần phải diễn giải cứ mỗi khi chạy, khiến tốc độ chạy chương trình chậm đi. Dù có lỗi cú pháp ở giữa chừng chương trình thì interpreter vẫn có thể chạy đến ngay trước lỗi đó.</p>
<p>※<em>Chỗ này thường ra này!</em></p>
<pre><code>*Thuật ngữ*
[アセンブラ] (Assembler): Dịch chương trình gốc được viết bằng ngôn ngữ Assembly sang ngôn ngữ máy
[コンパイラ] (Compiler): Tổng hợp lại chương trình gốc rồi dịch một lần sang ngôn ngữ máy
[ジェネレータ] (Generator): Chỉ thị từ parameter, tự động generate ra chương trình ứng với mục đích của xử lý
[インタプリタ] (Interpreter): Diễn giải rồi chạy từng lệnh 1 của chương trình gốc
</code></pre>
<p>※<em>Hãy biết cả điều này nữa</em></p>
<pre><code>*Translator và Emulator*
*Translator* là chương trình chuyển đổi chương trình gốc được viết cho xử lý nào đó 
thành chương trình gốc cho xử lý khác. *Emulator* là vi chương trình (micro program) 
giải mã, thực thi chương trình dùng cho máy tính khác.
</code></pre>
<h3 id=các-bước-cho-đến-khi-chạy-phần-mềm>Các bước cho đến khi chạy phần mềm</h3>
<p>Ta sẽ đi xem các bước đến khi một chương trình được viết bằng ngôn ngữ bậc cao theo phương thức Compiler trở thành phần mềm và được thực thi.</p>
<p><figure style=flex-grow:337;flex-basis:809px>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/steps-until-running-software.png data-size=2570x762><img src=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/steps-until-running-software.png srcset="/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/steps-until-running-software_hu4d31ae0f576c1b6e14138e1627f6e0ea_279649_480x0_resize_box_3.png 480w, /p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/steps-until-running-software_hu4d31ae0f576c1b6e14138e1627f6e0ea_279649_1024x0_resize_box_3.png 1024w" width=2570 height=762 loading=lazy>
</a>
</figure></p>
<h4 id=-compile>① Compile</h4>
<p>Trước tiên, nhờ vào <em>Compiler</em>, dịch chương trình gốc được viết bằng ngôn ngữ bậc cao sang chương trình đích với ngôn ngữ máy. Lúc này, sẽ đi phân tích chương trình gốc, <em>việc tối ưu hóa</em> sẽ được thực hiện để nâng cao hiệu quả xử lý khi thực thi.</p>
<h4 id=-link>② Link</h4>
<p>Khi tạo chương trình, không thể chạy với đơn lẻ một chương trình đích mà chỉ mới thực hiện compile. Cần phải gọi chương trình trong library module từ chương trình đích, gọi ra xử lý được viết ở chương trình gốc khác. Library module tức là tập hợp các chương trình đã bộ phận hóa để có thể sử dụng chương trình chứa chức năng xác định nào đó từ chương trình khác.
Tại đó, bổ sung thêm các library module cần thiết vào chương trình đích đã được dịch bằng compiler, rồi generate ra <em>Load module</em> là chương trình có thể thực thi. Công việc này được gọi là <em>Link</em> (Liên kết), chương trình thực hiện link được gọi là <em>Linker</em>.
Trong link thì có <em>Link tĩnh</em> và <em>Link động</em>. Link tĩnh là phương pháp link chương trình đích hay library module cần thiết bằng Linker trước khi chạy chương trình. Link động là cách link mà khi cần chức năng thuộc program module khác trong khi chạy chương trình, thì sẽ link chương trình đó bất cứ lúc nào cần. Library file tổng hợp nhóm module phần mềm với tiền đề link động được gọi là <em>DLL (Dynamic Link Library - thư viện liên kết động)</em>.</p>
<h4 id=-load>③ Load</h4>
<p>Công việc tải vào bộ nhớ chính để chạy load module được gọi là <em>Load</em>, do chương trình gọi là <em>Loader</em> đảm nhiệm.</p>
<p>※<em>Chỗ này thường ra này!</em></p>
<pre><code>*Thuật ngữ*
[最適化] (Tối ưu hóa): Khi compile, phân tích chương trình gốc, 
tạo chương trình đích nâng cao hiệu suất xử lý khi thực thi
[リンク] (Link): Kết hợp chương trình đích hay library module 
rồi generate ra Load module
[ロード] (Load): Bố trí load module vào bộ nhớ chính
</code></pre>
<p>※<em>Chỗ này thường ra này!</em></p>
<pre><code>*Thuật ngữ*
[動的リンク] (Link động): Trong khi đang chạy application, tùy theo độ cần thiết 
mà gọi thư viện liên kết động, kết hợp với bản thể chương trình
</code></pre>
<p>※<em>Hãy biết cả điều này nữa</em></p>
<pre><code>*Refactoring*
Việc thay đổi cấu trúc bên trong chương trình thay vì thay đổi spec bên ngoài 
để nâng cao tính bảo trì của phần mềm được gọi là *Refactoring*
</code></pre>
<h3 id=tính-chất-của-chương-trình>Tính chất của chương trình</h3>
<p>Một chương trình hoạt động nhanh, chính xác có thể nói là chương trình tốt, nhưng để tạo ra chương trình tốt như thế, quan trọng là phải hiểu được 4 tính chất của chương trình.</p>
<h4 id=có-thể-tái-sử-dụng-nối-tiếp-reusable>Có thể tái sử dụng nối tiếp (Reusable)</h4>
<p>Chương trình có thể chạy kể cả sau khi đã tạm thời chạy xong, dù không load lại lần nữa vào bộ nhớ chính được gọi là chương trình có thể tái sử dụng.
Trong đó, chương trình chỉ có thể sử dụng 1 tác vụ cùng một lúc gọi là <em>Chương trình có thể tái sử dụng liên tiếp</em>.</p>
<h4 id=có-thể-tái-nhập-reentrant>Có thể tái nhập (Reentrant)</h4>
<p>Trong số các chương trình có thể tái sử dụng, chương trình gọi cùng lúc từ 2 tác vụ trở lên mà vẫn hoạt động đúng được gọi là <em>Chương trình có thể tái nhập</em>. Do chương trình có thể tái nhập có phần code (thủ tục) và phần dữ liệu được chia ra ở từng vùng bộ nhớ riêng biệt, nên có thể xếp hàng rồi chạy bằng cách chuẩn bị phần dữ liệu theo từng tác vụ.</p>
<h4 id=có-thể-tái-định-vị-relocatable>Có thể tái định vị (Relocatable)</h4>
<p>Chương trình có thể chạy dù load ở bất cứ vị trí nào trong bộ nhớ chính được gọi là <em>Chương trình có thể tái định vị</em>.</p>
<h4 id=mang-tính-đệ-quy-recursive>Mang tính đệ quy (Recursive)</h4>
<p>Chương trình có thể tự gọi bản thân nó trong khi đang chạy gọi là <em>Chương trình mang tính đệ quy</em>.</p>
<p>※<em>Hãy biết cả điều này nữa</em></p>
<pre><code>*Reverse engineering*
Việc phân tích source code của chương trình, rồi dựng lại thông tin thiết kế hay spec của chương trình 
được gọi là *Reverse engineering*. Ví dụ, từ thông tin định nghĩa hệ thống cơ sở dữ liệu 
đang hoạt động trên thực tế, sử dụng tool tạo ERD, sinh ra bản thiết kế thể hiện bằng ERD, 
hay sinh ra sơ đồ class UML từ chương trình tương ứng với công việc này.
</code></pre>
<p>※<em>Chỗ này thường ra này!</em></p>
<pre><code>*Thuật ngữ*
[逐次再使用可能] (Có thể tái sử dụng nối tiếp): Miễn load 1 lần là có thể chạy bao nhiêu lần. 
Chỉ có thể sử dụng 1 tác vụ
[再入可能] (Có thể tái nhập): Có thể sử dụng với nhiều tác vụ cùng một lúc
[再配置可能] (Có thể tái định vị): Dù load ở bất cứ vị trí nào trên bộ nhớ chính thì vẫn có thể chạy
[再帰的] (Mang tính đệ quy): Có thể tự gọi bản thân nó
[リバースエンジニアリング] (Reverse engineering): Phân tích source code, dựng lại cấu trúc hay spec bên trong
</code></pre>
<p>※<em>Thử thách với bài test</em></p>
<pre><code>(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 22)
Khi xử lý của program A nọ chưa kết thúc, dù bị gọi lại từ program khác nhưng vẫn 
hoạt động đúng, thì lúc này, tính chất của program A này gọi là gì?
ア: Mang tính đệ quy
イ: Có thể tái sử dụng
ウ: Có thể tái nhập
エ: Có thể tái định vị
→ Answer: ウ
Giải thích: Dù bị gọi từ 2 chương trình trở lên cùng một lúc nhưng vẫn có thể chạy 
là Chương trình có thể tái nhập.
</code></pre>
<p>※<em>Thử thách với bài test</em></p>
<pre><code>(Fundamental Information Technology Engineer Examination Mùa xuân năm Heisei 21)
Sơ đồ bên dưới diễn tả flow dịch rồi thực thi chương trình. 
Cùng kết hợp với input, output là Compiler, Linker, Loader, thì phương án nào dưới đây là phù hợp nhất?
</code></pre>
<p><figure style=flex-grow:222;flex-basis:533px>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/test-diagram.png data-size=2300x1034><img src=/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/test-diagram.png srcset="/p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/test-diagram_hu072200196ca0181dcfdc4893bf9bcc95_395216_480x0_resize_box_3.png 480w, /p/fe-book_chapter-5-system-development_lesson-5-6-l%E1%BA%ADp-tr%C3%ACnh/test-diagram_hu072200196ca0181dcfdc4893bf9bcc95_395216_1024x0_resize_box_3.png 1024w" width=2300 height=1034 loading=lazy>
</a>
</figure></p>
<pre><code>→ Answer: ア
 Giải thích: Khi dịch chương trình gốc bằng Compiler, có thể ra &quot;Chương trình đích&quot;. 
Hơn nữa, &quot;Chương trình đích&quot; ghép thêm &quot;Library module&quot; vào bằng Linker, sẽ ra &quot;Load module&quot; 
có thể chạy, và được bố trí ở trên bộ nhớ chính bằng Loader.
</code></pre>
<p>※<em>Thử thách với bài test</em></p>
<pre><code>(Fundamental Information Technology Engineer Examination Mùa thu năm Heisei 26)
Việc sinh ra sơ đồ class UML từ program được gọi là gì?
ア: Backtracking
イ: Forward Engineering
ウ: Re‑engineering
エ: Reverse engineering
→ Answer: エ
Giải thích: Sơ đồ class UML là sơ đồ thiết kế chương trình hướng đối tượng. 
Việc phân tích chương trình, rút ra spec hay cấu trúc bên trọng được gọi là Reverse engineering.</code></pre>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/system_development/>system_development</a>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-5-thi%E1%BA%BFt-k%E1%BA%BF-chi-ti%E1%BA%BFt-ph%E1%BA%A7n-m%E1%BB%81m/>
<div class=article-details>
<h2 class=article-title>FE Book_Chapter 5: System development_Lesson 5-5: Thiết kế chi tiết phần mềm</h2>
</div>
</a>
</article>
<article>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-4-%C4%91%E1%BB%8Bnh-ngh%C4%A9a-y%C3%AAu-c%E1%BA%A7u-ph%E1%BA%A7n-m%E1%BB%81m-external-design/>
<div class=article-details>
<h2 class=article-title>FE Book_Chapter 5: System development_Lesson 5-4: Định nghĩa yêu cầu phần mềm (External design)</h2>
</div>
</a>
</article>
<article>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-3-m%C3%B4-h%C3%ACnh-h%C3%B3a-nghi%E1%BB%87p-v%E1%BB%A5/>
<div class=article-details>
<h2 class=article-title>FE Book_Chapter 5: System development_Lesson 5-3: Mô hình hóa nghiệp vụ</h2>
</div>
</a>
</article>
<article>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-2-c%C3%A1c-ph%C6%B0%C6%A1ng-ph%C3%A1p-ph%C3%A1t-tri%E1%BB%83n-h%E1%BB%87-th%E1%BB%91ng/>
<div class=article-details>
<h2 class=article-title>FE Book_Chapter 5: System development_Lesson 5-2: Các phương pháp Phát triển hệ thống</h2>
</div>
</a>
</article>
<article>
<a href=/p/fe-book_chapter-5-system-development_lesson-5-1-kh%C3%A1i-qu%C3%A1t-v%E1%BB%81-ph%C3%A1t-tri%E1%BB%83n-h%E1%BB%87-th%E1%BB%91ng/>
<div class=article-details>
<h2 class=article-title>FE Book_Chapter 5: System development_Lesson 5-1: Khái quát về Phát triển hệ thống</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2020 -
2021 Sakura Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.1.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li>
<ol>
<li><a href=#lập-trình-là-gì>Lập trình là gì?</a></li>
<li><a href=#ngôn-ngữ-lập-trình>Ngôn ngữ lập trình</a></li>
<li><a href=#language-processor-bộ-xử-lý-ngôn-ngữ>Language processor (Bộ xử lý ngôn ngữ)</a>
<ol>
<li><a href=#assembler>Assembler</a></li>
<li><a href=#compiler>Compiler</a></li>
<li><a href=#generator>Generator</a></li>
<li><a href=#interpreter>Interpreter</a></li>
</ol>
</li>
<li><a href=#các-bước-cho-đến-khi-chạy-phần-mềm>Các bước cho đến khi chạy phần mềm</a>
<ol>
<li><a href=#-compile>① Compile</a></li>
<li><a href=#-link>② Link</a></li>
<li><a href=#-load>③ Load</a></li>
</ol>
</li>
<li><a href=#tính-chất-của-chương-trình>Tính chất của chương trình</a>
<ol>
<li><a href=#có-thể-tái-sử-dụng-nối-tiếp-reusable>Có thể tái sử dụng nối tiếp (Reusable)</a></li>
<li><a href=#có-thể-tái-nhập-reentrant>Có thể tái nhập (Reentrant)</a></li>
<li><a href=#có-thể-tái-định-vị-relocatable>Có thể tái định vị (Relocatable)</a></li>
<li><a href=#mang-tính-đệ-quy-recursive>Mang tính đệ quy (Recursive)</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>